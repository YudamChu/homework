<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    function solution(n, w, num) {
    
    //1부터 n까지의 번호 담긴 배열 만들기
    const postNum = Array.from({length:n}, (_,i)=> i+1);
    
    //택배 박스 한줄에 w만큼 쌓기 (이차배열)
    const box = [];
    for(let i = 0; i<postNum.length; i+=w){
        box.push(postNum.slice(i, i+w));
    }
    
    //홀수 줄은 오름차순 짝수 줄은 내림차순
    //인덱스 번호가 짝수이면 오름차순 홀수이면 내림차순
    box.map((line, index) => index%2 !==0 && line.sort((a,b) => b-a));
    
    //꺼낼 박스의 번호가 있는 배열의 인덱스 값 찾기
    let arrIdx = '';
    box.forEach((numArr, i) => {numArr.includes(num) && (arrIdx=i)});
    
    //해당 배열에서 꺼낼 박스 번호가 몇번째 인덱스에 위치하는지 찾기
    let idx = box[arrIdx].indexOf(num);
    
    //꺼낼 박스 수 구하기
    //박스 높이가 짝수가 아닐 경우 
    //=> box의 마지막 배열의 길이가 찾고자 하는 박스의 인덱스 번호보다 길면 (총 박스 길이-num이 위치하는 배열 index)
    //=> 아니라면 맨 마지막 배열 빼기. 즉, (총 박스 길이-num이 위치하는 배열 index)-1
    if(box.length%2 !==0){
        return box[box.length-1].length >= idx+1? box.length-arrIdx : box.length-arrIdx-1;    
    }
    
    //박스 높이가 짝수일 경우 
    //=> box의 마지막 배열의 길이가 w와 같다면 (총 박스 길이-num이 위치하는 배열 index)
    //=> 아니라면 w와 맨 마지막 배열 길이의 차이보다 idx보다 클때는 맨마지막 배열 뺴기  
    //즉, (총 박스 길이-num이 위치하는 배열 index)-1
    //맨 마지막 배열 길이의 차이보다 idx보다 작을때는 (총 박스 길이-num이 위치하는 배열 index)
    if(box.length%2 ===0){
        if(box[box.length-1].length === w){
            return box.length-arrIdx;
        }else{
           indexDif = w - box[box.length-1].length;
           return idx < indexDif?  box.length-arrIdx-1: box.length-arrIdx;
        }
    }  
    
   
}
</script>
</html>